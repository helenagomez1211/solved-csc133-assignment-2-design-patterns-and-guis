Download Link: https://assignmentchef.com/product/solved-csc133-assignment-2-design-patterns-and-guis
<br>
<h2>Introduction</h2>

For this assignment you are to extend your game from Assignment #1 (A1) to incorporate several important <em>design patterns</em>, and a <em>Graphical User Interface</em> (GUI). The rest of the game will appear to the user to be similar to the one in A1, and most of the code from A1 will be reused, although it will require some modification and reorganization.

An important goal for this assignment will be to reorganize your code so that it follows the <em>Model-View-Controller (MVC) architecture</em>.  If you followed the structure specified in A1, you should already have a “controller”: the <strong>Game</strong> class containing the <strong>play() </strong>method. The <strong>GameWorld</strong> class becomes the “data model”, containing the collection of game objects and other game state information. You are also required to add two classes acting as “<em>views</em>”: a <em><u>score</u></em> view which will be graphical, and a <em><u>map</u></em> view which for now will retain the text-based form generated by the ‘m’ command in A1 (in A3 we will replace the text-based map with an interactive graphical map).

Single-character commands entered via a text field in A1 will be replaced by GUI components (side menu items, buttons, key bindings, etc.). Each such component will have an associated “command” object, and the command objects will perform the same operations as previously performed by the single-character commands.

The program must use appropriate interfaces and build-in classes for organizing the required design patterns. The following design patterns are to be implemented in this assignment:

<ul>

 <li><em>Observer/Observable</em> – to coordinate changes in the model with the various views,</li>

 <li><em>Iterator </em>– to walk through all the game objects when necessary,</li>

 <li><em>Command </em>– to encapsulate the various commands the player can invoke,</li>

 <li><em>Strategy </em>– to control movement for additional (non-player) robots.</li>

 <li><em>Singleton </em>– to ensure that only a single instance of player robot can exist.</li>

</ul>

<h2>Model Organization</h2>

<strong>GameWorld</strong> is to be reorganized so that it has a <strong>GameObjectCollection</strong> which contains a collection of <em>game objects</em>. All game objects are to be contained in this <em>single</em> collection. Any routine that needs to process the objects in the collection must access the collection via an iterator (described below).

The model is also to contain the same game state data as A1 (current clock time and lives remaining), plus a new state value: a flag indicating whether <em>Sound</em> is ON or OFF (described below).

<h2>Views</h2>

A1 contained two functions to output game information: the ‘m’ key for outputting a “map” of the game objects in the <strong>GameWorld</strong>, and the ‘d’ key for outputting current <em>game/playerrobot state data</em> (i.e., the number of lives left, the current clock value, last base number the player’s robot has reached sequentially so far, the player robot’s current energy level, and player robot’s current damage level). Each of these two operations is to be implemented in this assignment as a <strong><em>view</em></strong> of the <strong>GameWorld</strong> model. To do that, you will need to implement two new classes: a <strong><em>MapView</em></strong> class containing code to output the map, and a <strong><em>ScoreView</em></strong> class containing code to output the current game/player-robot state information.

To implement this,<strong> GameWorld</strong> should be defined as an <em>observable</em>, with two <em>observers</em>– <strong>MapView</strong> and <strong>ScoreView.</strong> Each of these should be “registered” as an observer of <strong>GameWorld</strong>. When the controller invokes a method in <strong>GameWorld</strong> that causes a change in the world (such as a game object moving, or a new energy station being added to the world) the <strong>GameWorld</strong> notifies its observers that the world has changed. Each observer then automatically produces a new output view of the data it is observing – the game world objects in the case of <strong>MapView</strong>, and a description of the game/player-robot state values in the case of <strong>ScoreView</strong>. The <strong>MapView</strong> output for this assignment is unchanged from A1: text output on the console showing all game objects which exist in the world. However, the <strong>ScoreView</strong> is to present a <em>graphical</em> display of the game/player-robot state values (described in more detail below).

Recall that there are two approaches which can be used to implement the Observer pattern:  defining your own <strong>IObservable</strong> <u>interface</u>, or extending the build-in CN1 <strong>Observable</strong> <u>class</u>.  You are required to use the latter approach (where your <strong>GameWorld</strong> class extends <strong>java</strong>.<strong>util</strong>.<strong>Observable</strong>) and the tips for it are given at the end of the handout. Note that you are also required to use the build-in CN1 <strong>Observer</strong> interface (which also resides in <strong>java</strong>.<strong>util</strong> package).

In order for a view (observer) to produce the new output, it will need access to some of the data in the model. This access is provided by passing to the observer’s <strong>update()</strong> method  a parameter that is a reference back to the model (which is done automatically by the <strong>notifyObservers()</strong> built-in method when built-in <strong>Observable</strong> class is used). Note this has the undesirable side-effect that <em>the view has access to the model’s <u>mutators</u></em>, and hence could <em>modify</em> model data (later in the lectures, we will discuss how to address this issue with the Proxy pattern).

<h2>Non-Player Robots (NPRs)</h2>

The “game object” hierarchy will be the same as in A1 except that you will add a new kind of movable object called <strong>NonPlayerRobot,</strong> which extends from <strong>Robot</strong>.  The game initialization code should create and add to the game world three instances of <strong>NonPlayerRobot</strong> (so that there are now four robots – the player’s robot which is an instance of Robot plus three “Non-Player Robots (NPRs)”.  Each NPR is to have an initial location which is “near” the first base, but not exactly <em>at </em>the first base; instead, each NPR should be at least several robot lengths away from the first base (this is to make sure that the NPRs are not colliding with the player’s robot to start with).

When an NPR collides with the player’s robot, the player’s robot sustains <em>damage </em>just as described in A1 – including that if the robot sustains so much damage that it can no longer move the player loses a life, and the world is reinitialized.   NPRs also sustain damage when they collide, but you should initialize them with much higher values so that they can compete longer (consider NPRs to be “armored” so that they can sustain more damage).

NPRs will be controlled by separate pieces of code called <em>strategies </em>which can be altered using a new “<em>Change Strategies</em>” command; this is described under “Strategy Pattern”, below.

Having NPRs in this version of the game introduces an additional case for ending the game such that if a NPR reaches the last base before the player does, the game will end with the following message displayed on the console: “Game over, a non-player robot wins!”.

<h2>GUI Operations</h2>

<strong>Game</strong> class extends <strong>Form</strong> (as in A1) representing the top-level container of the GUI. The form should be divided into five areas: one for “score” information, three for commands, and one for the “map” (which will be an empty container for now but in subsequent assignments will be used to display the map in graphical form). See the sample picture at the end. Note that since user input is via GUI components, flow of control will now be event-driven and there is no longer any need to invoke the <strong>play()</strong> method – once the <strong>Game</strong> is constructed it simply waits for user-generated input events. Note however that it is still a requirement to have a “<strong>Starter</strong>” class as described in A1.

Hence, in this assignment, the <strong>play()</strong> method used in A1 which prompts for singlecharacter commands and reads them from a text field on the form is to be discarded. In its place, commands will be input through <u>three</u> different mechanisms: on-screen buttons, key bindings, and side menu items (we will also utilize a tile bar area item to provide help as explained below).  Each command will be invokable via a combination of these mechanisms. You are to create <em>command objects </em>(see below) for each of the commands from A1 (except “d” and “m” which are implemented as views in A2, and “y” and “n” which are replaced by an exit dialog box – see below) and for new commands introduced in A2 (i.e., change strategies, sound, about, and help). You are to attach the objects as commands to various combinations of invokers as shown in the following table (a ‘+’ in a column indicates that the command in that row is to be able to be invoked by the mechanism in the column header):

<table width="612">

 <tbody>

  <tr>

   <td width="212"><strong>Command </strong></td>

   <td width="112"><strong>KeyBinding </strong></td>

   <td width="197"><strong>Side Menu (or Title Bar Area) Item </strong></td>

   <td width="90"><strong>Button </strong></td>

  </tr>

  <tr>

   <td width="212"><strong><u>a</u></strong>ccelerate</td>

   <td width="112">+</td>

   <td width="197"> +</td>

   <td width="90"> +</td>

  </tr>

  <tr>

   <td width="212"><strong><u>b</u></strong>rake</td>

   <td width="112">+</td>

   <td width="197"> </td>

   <td width="90"> +</td>

  </tr>

  <tr>

   <td width="212"><strong><u>l</u></strong>eft turn</td>

   <td width="112">+</td>

   <td width="197"> </td>

   <td width="90"> +</td>

  </tr>

  <tr>

   <td width="212"><strong><u>r</u></strong>ight turn</td>

   <td width="112">+</td>

   <td width="197"> </td>

   <td width="90"> +</td>

  </tr>

  <tr>

   <td width="212">collide with NPR</td>

   <td width="112"> </td>

   <td width="197"> </td>

   <td width="90">+</td>

  </tr>

  <tr>

   <td width="212">collide with base</td>

   <td width="112"> </td>

   <td width="197"> </td>

   <td width="90">+</td>

  </tr>

  <tr>

   <td width="212">collide with<strong> <u>e</u></strong>nergy station</td>

   <td width="112">+</td>

   <td width="197"> </td>

   <td width="90">+</td>

  </tr>

  <tr>

   <td width="212">collide with drone (<strong><u>g</u></strong>)</td>

   <td width="112">+</td>

   <td width="197"> </td>

   <td width="90">+</td>

  </tr>

  <tr>

   <td width="212"><strong><u>t</u></strong>ick</td>

   <td width="112">+</td>

   <td width="197"> </td>

   <td width="90">+</td>

  </tr>

  <tr>

   <td width="212">exit</td>

   <td width="112"> </td>

   <td width="197">+</td>

   <td width="90"> </td>

  </tr>

  <tr>

   <td width="212">change strategies</td>

   <td width="112"> </td>

   <td width="197"> </td>

   <td width="90">+</td>

  </tr>

  <tr>

   <td width="212">turn the sound on or off</td>

   <td width="112"> </td>

   <td width="197">+</td>

   <td width="90"> </td>

  </tr>

  <tr>

   <td width="212">give about information</td>

   <td width="112"> </td>

   <td width="197">+</td>

   <td width="90"> </td>

  </tr>

  <tr>

   <td width="212">give help information</td>

   <td width="112"> </td>

   <td width="197">+</td>

   <td width="90"> </td>

  </tr>

 </tbody>

</table>




For west, east, and south regions on the form (<strong>Game</strong>), you should have a different <strong>Container</strong> (another build-in CN1 class) object created. For north and center regions, you should have a <strong>ScoreView </strong>and a <strong>MapView</strong> object created, respectively. <strong>ScoreView</strong> and <strong>MapView</strong> classes should extend from <strong>Container</strong>.  <strong>MapView</strong> will be an empty container whereas you should add appropriate labels (use CN1 build-in <strong>Label</strong> class) to <strong>ScoreView </strong>(see below for details). Adding the labels to the <strong>ScoreView</strong> should be done in the constructor of the <strong>ScoreView</strong>. For regions with buttons (i.e., west, east, and south), after you create their <strong>Container</strong> objects (which we will call as “control containers”), you should add related buttons  to these containers.

Each button is to have an appropriate command object attached to it, so that when a button gets pushed it invokes the <strong>actionPerformed()</strong> method in the corresponding command object (the <strong>execute()</strong> method in terms of the Command pattern), which contains the code to perform the command.

Most commands execute exactly the same code as was implemented in A1.  One exception is the “collide with base” command.  Previously this command consisted of a number (between 1-9) entered from the text field located on the form which we eliminate in A2.  Now, this command is to use the static method <strong>Dialog.show() </strong>to display a dialog box that allows the user to enter the number on a text field located on the dialog box (please see the “Titled Form in CN1” slide of “GUI Basics” chapter in lecture notes for more information).  Note that if the user inputs an invalid value; your program should handle this gracefully.  <strong> </strong>

The other command which must operate slightly different in this assignment is ‘<strong><u>c</u></strong>’ (player’s robot <strong><u>c</u></strong>ollided with NPR).  In A1, this command just increased the damage level of the <u>player’s</u> robot.  Now, the command is to <u>also</u> add damage to one of the NPRs:  the ‘<strong><u>c</u></strong>’ command code should choose one NPR and increase that NPR’s damage as well.  To make the game more fair you should really alternate between NPRs when this command is entered, but it is acceptable to use any algorithm (including choosing an NPR randomly, or always choosing the same NPR).  We will change how this works in the next assignment, so any approach in A2 is fine.

The “key binding” input mechanism will use the CN1 <em>key binding </em>concept so that the <em>“a”, “b”, “l”, “r”, “e”, “g”, </em>and<em> “t” </em>keys invoke command objects corresponding to the code previously executed when the <em>“a”, “b”, “l”, “r”, “e”, “g”, </em>and<em> “t” </em>single-character commands were entered, respectively. Note that using key bindings means that whenever a key is pressed, the program will <em>immediately</em> invoke the corresponding action (without the user pressing the Enter key). If you want, you may also use key bindings to map any of the other command keys from A1, but only the ones listed here are required.

The “side menu item” input mechanism will use a side menu (see class notes for tips on how to create a side menu using CN1 build-in <strong>Toolbar</strong> class). Your GUI will contain a side menu that contains the following items: “Accelerate”, “Sound”, “About”, and “Exit”. “Accelerate” menu item should invoke “a” command. “Sound” menu item should include a check box showing the current state of the “sound” attribute (in addition to the attribute’s state being shown on the <strong>ScoreView</strong> container as described below). Selecting the Sound menu item check box (use CN1 build-in <strong>CheckBox</strong> class) should set a boolean “sound” attribute to “ON” or “OFF”, accordingly. The “About” menu item is to display a dialog box (use CN1 build-in <strong>Dialog</strong> class) giving your name, the course name, and any other information (for example, the version number of the program) you want to display. “Exit” side menu item should invoke “x” command. Note that in A2 the “x” command should prompt graphically for confirmation and then exit the program; you should also use a dialog box for this.

Side menu will be placed on the left side of the title bar area. You are also required to add a “Help” item to the right side of the title bar area. When “Help” is invoked, you are required to display a dialog box listing the keys user can use while playing the game.

Selecting a side menu item that performs a game command (e.g., “Accelerate” menu item) should invoke the same code, when the button of the same name had been pushed (e.g., “Accelerate” button) and/or its related key has been hit (e.g., “a” key). Recall that there is a requirement that commands be implemented using the <em>Command</em> design pattern. This means that there must be <em><u>only one</u> </em>of each type of command object, which in turn means that the menu items, key bindings, and buttons must share their command objects. (We could <em>enforce </em>the rule using the <em>Singleton</em> design pattern, but that is not a requirement in A2; just don’t create more than one of any given type of command object).

The <strong>ScoreView</strong> class should display <em>game/player-robot state data</em> (i.e., clock value, lives left, the player robot’s last base reached, the player robot’s energy level, and the player robot’s damage level), plus one <em>new </em>attribute: <em>“Sound”</em> with value either ON or OFF.<a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a> You should add several labels to the <strong>ScoreView</strong> to create this display. As described above, <strong>ScoreView</strong> must be registered as an observer of <strong>GameWorld</strong>. Whenever any change occurs in the world, <strong>GameWorld</strong> calls <strong>notifyObsersevers()</strong> (do not forget to call <strong>setChanged()</strong> first) which in turn calls the <strong>update()</strong> method in its observers (you do not need to call <strong>update()</strong>yourself, it is automatically called). In the case of the <strong>ScoreView</strong>, what <strong>update()</strong> does is updating the contents of the labels displaying the game/player-robot state (use <strong>Label</strong> method <strong>setText()</strong> to update the label; if you cannot see a change on labels when you call <strong>setText()</strong>, try calling <strong>repaint() </strong>on the <strong>ScoreView</strong>).  Note that these are exactly the same game/player-robot state values as were displayed previously (with the addition of the “Sound” attribute); the only difference now is that they are displayed <em>graphically </em>in <strong>ScoreView</strong>.

Although we cover most of the GUI building details in the lecture notes, there will most likely be some details that you will need to look up using the CN1 documentation (i.e., CN1 JavaDocs and developer guide). It will become increasingly important that you familiarize yourself with and utilize these resources.

<h2>Command Design Pattern</h2>

The approach you must use for implementing command classes is to have each command extend the CN1 build-in <strong>Command</strong> class (which implements the <strong>ActionListener</strong> interface), as shown in the course notes. Code to perform the command operation then goes in the command’s <strong>actionPerformed()</strong> method. Hence, <strong>actionPerformed()</strong> method of each command class that performs an operation invoked by a single-character command in A1, should call the appropriate method in the <strong>GameWorld</strong> that you have implemented in A1 when related single-character command is entered from the text field (e.g., accelerate command’s <strong>actionPerformed()</strong> would call <strong>accelerate()</strong> method in <strong>GameWorld</strong>). Hence, most command objects need to have the <strong>GameWorld</strong> as its target since they need to access the methods defined in this class. You could implement the specification of a command’s target either by passing the target (reference to <strong>GameWorld</strong>) to the command constructor, or by including a “<strong>setTarget()</strong>” method in the command.

<strong>Button</strong> class is automatically able to be a “holder” for command objects; <strong>Button</strong> have a <strong>setCommand()</strong> method which allows inserting a command object into the button. <strong>Command</strong> <u>automatically</u> becomes a listener when added to a <strong>Button</strong> via <strong>setCommand()</strong> (you do not need to also call <strong>addActionListener()</strong>), and the specified <strong>Command</strong> is automatically invoked when the button is pressed, so if you use the CN1 facilities correctly then this particular observer/observable relationship is taken care of automatically.

The <strong>Game</strong> constructor should create a <em>single</em> instance of each command object (for example, a “Accelerate” command object, a “Brake” command object, etc.), then insert the command objects into the command holders (buttons, side menu items, title bar area items) using methods like <strong>setCommand() </strong>(for buttons), <strong>addCommandToSideMenu()</strong> (for side menu items), and <strong>addCommandToRightBar()</strong> (for title bar area items). You should also bind these command objects to the keys using <strong>addKeyListener()</strong> method of <strong>Form</strong>.  You must call <strong>super(“command_name”)</strong> in the constructors of command objects by providing appropriate command names. These command names will be used to override the labels of buttons and/or to provide the labels of side menu items or title bar area item(s).

Note that commands can be invoked using multiple mechanisms (e.g., from a keystroke and from a button); it is a requirement that only <em>one </em>command object be implemented for each command and that the <em>same</em> command object be invoked from each different command holder.  As a result, it is important to make sure that nothing in any command object contains knowledge of <em>how</em> (e.g., through which mechanism) the command was invoked.

<h2>Iterator Design Pattern</h2>

The game object collection must be accessed through an appropriate implementation of the <em>Iterator</em> design pattern. That is, any routine that needs to process the objects in the collection must not access the collection directly, but must instead acquire an iterator on the collection and use that iterator to access the objects. You should develop your own interfaces to implement this design pattern, instead of using the related build-in CN1 interfaces. The game object collection will implement an interface called <strong>ICollection</strong> which defines at least two methods: for adding an object to the collection (i.e., <strong>add()</strong>) and for obtaining an iterator over the collection (i.e., <strong>getIterator()</strong>).  The iterator should exist as a private inner class inside game object collection class and should implement an interface called <strong>IIterator</strong> which defines at least two methods: for checking whether there are more elements to be processed in the collection (i.e., <strong>hasNext())</strong> and returning the next element to be processed from the collection (i.e., <strong>getNext())</strong>.

Note however the following implementation requirement: the game object collection must provide an iterator <em><u>completely implemented by you</u></em>. Even if the data structure you use has an iterator provided by CN1, you must implement an iterator yourself: The iterator should keep track of the current index and it cannot make use of the built-in iterator defined for the data structure (e.g., you cannot call <strong>hasNext()</strong> method of the built-in iterator  defined for <strong>Vector/ArrayList</strong> from the <strong>hasNext()</strong> method of your iterator class). However, the iterator can use following build-in methods of the data structure: <strong>size()</strong> and <strong>elementAt()/get()</strong>.

<h2>Strategy Design Pattern</h2>

NPRs move around the world according to their current <em>strategy</em>.  That is, the NPR uses the current strategy of that robot to determine the steering direction and speed, and the strategy can be changed on the fly (i.e. while the program is running). You are to implement at least two different NPR movement strategies:  the first strategy causes the NPR to move directly toward the next base (that is, the base with a sequence number one higher than the one it most recently encountered); the second strategy causes the NPR to update its heading every time it is told to move so that the heading points toward the location of the player’s robot (in other words, its strategy is to play “Attack” by trying to collide into the player’s robot).  You may also implement additional strategies if you like, although this is not required (for example, you might have a strategy where an NPR simply moves in circles, or a strategy where it moves back-and-forth between two bases).

The program must use the Strategy design pattern to define the strategy for each NPR.  You must use <strong>IStrategy</strong> interface instead of utilizing an abstract strategy super class. You should add two methods called <strong>setStrategy()</strong> and <strong>invokeStrategy() </strong>and a field for saving the current strategy to the NPR class. When an NPR is created it should be assigned a strategy chosen from among the available strategies.  It is a requirement that NPRs may not all have the same initial strategy; other than that you may assign initial strategies however you choose.  Like all game objects, NPRs should include a <strong>toString()</strong> method; the NPR <strong>toString()</strong> should return a string which includes the NPR’s information provided for a player robot plus an identification of that NPR’s current strategy.

When the human player invokes the “<em>switch strategy</em>” command (which happens when the appropriate GUI button is pressed), the game should cause all NPRs to <em>switch to a different movement strategy</em>.  Switching strategies is to be done by invoking the NPR’s <strong>setStrategy()</strong> method. You may choose the algorithm which determines the new NPR strategy, as long as every NPR acquires a new strategy each time the “switch strategy” command is invoked.  Additionally, you should arrange that as a side effect of “switching strategies”, each NPR gets the next “last base reached” value (otherwise, NPRs will never move beyond Base #2 since we have no command analogous to “collide with base” which applies to NPRs). Also, you should arrange so that NPRs never run out of energy (e.g., NPRs do not need to collide with energy, if the NPR’s energy level is getting low, you should set it to a reasonable value).

<h2>Additional Notes</h2>

<ul>

 <li>It is a requirement that the program contain only a <em>single </em>instance of player robot. This requirement must be enforced via the <em>Singleton</em> design pattern.</li>

 <li>You must use <strong>BorderLayout</strong> as the layout manager of your form and use <strong>FlowLayout</strong> or <strong>BoxLayout</strong> for the containers you have added to different areas of your form. These layout managers automatically place and size the containers/components that you have added to your form/containers.</li>

 <li>You can change the size of your buttons/labels using <strong>setPadding()</strong> method of <strong>Style </strong> Each label in <strong>ScoreView</strong> should be divided into two parts, text and value, and padding should be added to the value part so that the labels look stable when value changes as discussed in the class notes. You can also use <strong>setPadding()</strong> on left and right control containers to start adding buttons at positions which are certain pixels below their upper borders.</li>

 <li>In A2, you must assign the size of your game world by querying the size of your <strong>MapView</strong> container (instead of assigning your width and height to 1024×768 as in A1, assign them to width and height of <strong>MapView</strong>) using <strong>getWidth()</strong> and <strong>getHeight()</strong> method of <strong>Component</strong> as discussed in the class notes.</li>

 <li>You must change the style of your buttons using methods like <strong>setBgTransparency(), setBgColor(), setFgColor() </strong>of <strong>Sytle</strong> class so that they look different from labels as discussed in the class notes. You can extend from the built-in <strong>Button</strong> class and do the styling in this new class. Then, while you construct your GUI, instead of creating instances of the build-in <strong>Button</strong> class, you can create objects out of this new user-defined button class.</li>

 <li>Note that all game data manipulation by a command is accomplished by the command object invoking appropriate methods in the <strong>GameWorld</strong> (the model). Note also that <em>every</em> change to the <strong>GameWorld</strong> will invoke <em>both</em> the <strong>MapView</strong> and <strong>ScoreView</strong> observers – and hence generate the output formerly associated with the “m” and “d” commands. This means you do not need the “d” or “m” commands; the output formerly produced by those commands is now generated by the observer/observable process. Please note that even though some changes to the <strong>GameWorld</strong> may not relate to the data displayed in all observers (e.g., changes introduced by the ‘accelerate’ command only relate to the data displayed in <strong>MapView</strong> not in <strong>ScoreView</strong>), every time a change happens, it is okay to invoke all observers.</li>

 <li>Since almost all commands change the <strong>GameWorld </strong>(i.e., all command but exit, about, and help), they produce updated views as side effects. For instance, since the ‘tick’ command causes opponents to move, every ‘tick’ will result in a new map view being output (because each tick changes the model). Note however that it is <em>not</em> the responsibility of the ‘tick’ command code to produce this output; it is a side effect of the observable/observer pattern. You should verify that your program correctly produces updated views automatically whenever it should.</li>

 <li>You may found the following formula useful while implementing the NPR strategies:</li>

</ul>




(image from a tutorial at http://www.invasivecode.com/)

Here, (x0,y0) is the current location of the NPR, (x1,y1) is where it wants to go (target), then B is the ideal compass angle (90 – ideal_heading) for the NPR so it can go towards its target. Based on this information NPR should change its steering direction accordingly in order to approach this ideal heading. To calculate <em>arc tan</em> you can use <strong>atan()</strong> method of CN1 <strong>MathUtil</strong> class which generates angle in “radians”. If you need, you can use <strong>MathUtil.toDegrees() </strong>to convert radians to degrees.

<ul>

 <li>You may <u>not</u> use a CN1’s “GUI Builder” tool for this assignment.</li>

 <li>Programs must contain appropriate documentation as described in A1 and in class.</li>

 <li>Your program must be contained in a CN1 project called A2Prj. You must create your project following the instructions given at “2 – Introduction to Mobile App Development and CN1” lecture notes posted at SacCT (Steps for Eclipse: 1) File → New → Project → Codename One Project. 2) Give a project name “A2Prj” and uncheck “Java 8 project” 3) Hit “Next”. 4) Give a main class name “Starter”, package name “com.mycompany.a2”, and select a “native” theme, and “Hello World(Bare Bones)” template (for manual GUI building). 5) Hit “Finish”.). Further, <strong><em><u>you must verify that your program works properly from the</u> <u>command prompt </u></em></strong>before submitting it to SacCT (Get into the A2Prj directory and type “java -cp distA2Prj.jar;JavaSE.jar com.codename1.impl.javase.Simulator com.mycompany.a2.Starter” for Windows machines. For the command line arguments of Mac OS/Linux machines please refer to the class notes.). Substantial penalties will be applied to submissions which do not work properly from the command prompt.</li>

 <li>All functionality from the previous assignment must be retained unless it is explicitly changed or deleted by the requirements for this assignment.</li>

 <li>As before, you should develop a <em>UML diagram</em> showing the relationships between your classes/interfaces (and built-in classes/interfaces that your entities extend/implement). This will be particularly useful in helping you understand what modifications you need to make to your code from A1.</li>

 <li>You must use a tool to draw your UML (e.g., Violet or any other UML drawing tool) and output your UML as a pdf file (e.g., print your UML to a pdf file). For your entities you must use three-box notation (for built-in entities use single-box notation) and show all the important fields and methods. You must indicate the visibility modifiers of your fields and methods, but you are not required to show parameters in methods and return types of the methods.</li>

 <li>Although the <strong>MapView</strong> container is empty for this assignment, you should put a red border around it and install it in the form, to at least make sure that it is there (use <strong>setBorder()</strong> method of <strong>Style</strong> class as described in the class notes).</li>

</ul>

<h2>Sample GUI</h2>

The following shows how your game GUI should look like.  Notice that it has three control containers containing all the required buttons (on the left, right, and bottom), a side menu and “Help” item on title bar area, a <strong>ScoreView</strong> container near the top showing the current game/player-robot state information, and an (empty) bordered<strong> MapView</strong> container in the middle for future use (notice that there is a red border around the <strong>MapView</strong>).  The title “RoboTrack Game” also displays on title bar area.




<h2>Deliverables</h2>

Submitting your program requires the similar steps as for A1:

<ol>

 <li>Be sure to verify that your program works from the command prompt as explained above.</li>

 <li>Create a “<u>ZIP</u>” file containing (1) your <u>UML diagram</u> in .PDF format, (2) the entire “<u>src”</u> <u>directory</u> under your CN1 project directory (called A2Prj) which includes source code (“.java”) for all the classes in your program, and (3) the <u>jar</u> (located under the “A2Prj/dist” directory) which is automatically generated by CN1 and includes the compiled (“.class”) files for your program in a zipped format. Be sure to name your ZIP file as YourLastNameYourFirstName-a2.zip.</li>

 <li>Create a “<u>TEXT”</u> (i.e., not a pdf, doc etc.) file called “readme.txt” that includes your name and whether you have tested your submission on a lab machine. You are <strong>strongly encouraged</strong> to run and test your program on a lab machine (Hydra terminal server is recommended) before submitting your project. If you have done this test, also specify the lab number and the name of the specific machine you have used in that lab (or if you have used Hyrda as recommended, just say it was tested on Hydra) in the text file. In addition, if you have done this test, be sure that you include the <em>src</em> folder and <em>jar</em> file generated/tested on the lab machine in the above-mentioned zip file. This information helps the grader in case your submission does not work on the machine (s)he uses. You may also include additional information you want to share with the grader in this text file. You will receive the grader comments on your text file when grades are posted.</li>

 <li>Login to <strong><em>Canvas</em></strong>, select “Assignment#2”, and upload your ZIP file and TEXT file separately (do <strong>NOT </strong>place this TEXT file inside the ZIP file). Also, be sure to take note of the requirement stated in the course syllabus for keeping a <em><u>backup copy</u></em> of all submitted work (save a copy of your ZIP and TEXT files).</li>

</ol>

<em> </em>

<em><u>All submitted work must be strictly your own</u>! </em>




<h2>CN1 Notes</h2>

Below is the organization for your MVC code for A2. Note that in this organization, we are using the CN1 “Observable” class and CN1 “Observer” interface to create your <strong>GameWorld</strong> and views. Doing it this way has the benefit of CN1 handling the “list of observers” for you. Note also that this pseudo-code shows one way of registering Observers with Observables: having the controller handle the registration. It is also possible to have each Observer handle its own registration in its constructor (examples are shown in the course notes). You may use either approach in your program.




<strong>public class Game extends Form {    private GameWorld gw; </strong>

<strong>      private MapView mv;           </strong>// new in A2<strong>  private ScoreView sv;         </strong>// new in A2

<strong>      public Game(){ </strong>

<strong>  gw = new GameWorld();    </strong>// create “Observable” GameWorld  <strong> mv = new MapView();      </strong>// create an “Observer” for the map

<strong>             sv = new ScoreView();   </strong>// create an “Observer” for the game/player-robot

// state data

<strong>            gw.addObserver(mv);      </strong>// register the map observer      <strong>gw.addObserver(sv);</strong>      // register the score observer

// code here to create Command objects for each command,

// add commands to side menu and title bar area, bind commands to keys, create

// control containers for the buttons, add buttons to the control containers,

// add commands to the buttons, and add control containers, MapView, and  // ScoreView to the form

<strong>            this.show(); </strong>

<strong>            …</strong> // code here to query MapView’s width and height and set them as world’s

// width and height<strong>  </strong>

<strong>      </strong>       <strong>gw.init();</strong>                 // initialize world

<strong>      } </strong>

<strong>} </strong>

<strong>public class GameWorld extends Observable { </strong><em> </em><strong>public void init(){ </strong>

<strong>  </strong>//code here to create the initial game objects

<em> </em><strong>} </strong>

// additional methods here to manipulate game objects and related game state data

<strong>}  public class MapView extends Container implements Observer {  public void update (Observable o, Object arg) { </strong>

// code here to call the method in GameWorld (Observable) that output the

// game object information to the console




<strong>      } </strong>

<strong>} public class ScoreView extends Container implements Observer {  public void update (Observable o, Object arg) { </strong>

// code here to update labels from the game/player-robot state data

<strong>      } </strong>

<strong>} </strong>

<strong> </strong>

<a href="#_ftnref1" name="_ftn1">[1]</a>  In this version of the game there will not actually be any sound; just the state value ON or OFF (a boolean attribute that is <em>true</em> or <em>false</em>).  We’ll see how to actually add sound later.